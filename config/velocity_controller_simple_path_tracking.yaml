nominal_control_enabled: True # default:True
obstacle_avoidance_enabled: True # default:True 
stress_avoidance_enabled: True # default:True 

# if the control output is invalid for this time, the controller stops:
valid_control_output_wait_timeout: 5.0 # (seconds) 

## -------------------------------------------------------
## Nominal Velocity controller parameters

# Nominal Controller Gains [x,y,z, Rx,Ry,Rz]
# kp: [0.05,0.05,0.025, 0.15,0.15,0.15]
kp: [1.0,1.0,1.0, 1.5,1.5,1.5]
# kp: [0.03,0.03,0.03, 0.05,0.05,0.05]
# kp: [0.02,0.02,0.02, 0.1,0.1,0.1]
# kp: [0.06,0.06,0.03, 0.03,0.03,0.03]
kd: [0.0,0.0,0.0, 0.0,0.0,0.0]

# Particle/Segment ids of the tip points of the tent pole 
# to be placed into the grommets
tip_particles: [0,39]

# Grommet poses as targets for the tip points
# Each element holds [[x,y,z],[Rx,Ry,Rz(euler angles in degrees)]]
target_poses: [[[-1, -1, 0.14], [5,   0, 90]],
               [[ 1, -1, 0.14], [175, 0, 90]]]

# # For TEST
# target_poses: [[[-1.215,  2.00, 0.5], [90, 0, 0]],
#                [[-1.215, -0.43, 0.5], [90, 0, 0]]]

# # # For TEST
# target_poses: [[[2.5,  1.215, 0.5], [90, 0, 0]],
#                [[2.5, -1.215, 0.5], [90, 0, 0]]]

# Maximum velocity limits for each robot
# Any velocity command exceeding these limits will be scaled down to these values
max_linear_velocity: 0.1 # [m/s]
max_angular_velocity: 0.15 # [rad/s]

# Acceptable error for the target pose to stop the controller
# If the average error is less than this value, the controller stops
acceptable_pos_err_avr_norm: 0.1 # 0.2 # [m] # note: d_obstacle_offset is added to this value
acceptable_ori_err_avr_norm: 0.01 # 0.1 # [rad] 


## -------------------------------------------------------
## Path planning parameters
path_planning_mockup_enabled: True # default: False
path_tracking_control_enabled: True # default: True

# Waypoint poses for the path planning for the centeroid of the tent pole (assuming the tent pole is a rigid link)
# A path is generated between these waypoints using a simple spline interpolation between them as a reference path
# as a mockup for the path planning. 
# In the future, the path planning will be done using an actual path planner node and the path will be subscribed 
# by this controller node as a topic. 
# Each element holds [[x,y,z],[Rx,Ry,Rz(euler angles in degrees)]]
waypoint_poses: [[[0,  1.55, 1.10], [90, 0, 90]],
                 [[0,  0.45, 1.10], [90, 0, 90]],
                 [[0, -1.0, 0.16], [90, 0, 90]]]

# # FOR TEST
# waypoint_poses: [[[0,  1.5, 1.10], [45, 0, 90]],
#                  [[0,  0.5, 1.10], [135, 0, 90]],
#                  [[0, -1.0, 0.16], [90, 0, 90]]]

# # # FOR TEST
# waypoint_poses: [[[-1.215,  0.8225, 0.5], [90, 0, 0]]]

# # # FOR TEST
# waypoint_poses: [[[2.5,  0.0, 0.5], [90, 0, 0]]]

# Path tracking controller gains [x,y,z, Rx,Ry,Rz]
# kp_path_tracking: [0.0,0.0,0.0, 0.0,0.0,0.0]
# kp_path_tracking: [1.0,1.0,1.0, 1.5,1.5,1.5]
kp_path_tracking: [0.05,0.05,0.05, 0.075,0.075,0.075]

kd_path_tracking: [0.0,0.0,0.0, 0.0,0.0,0.0]

# Path tracking switch off parameters used in the sigmoid function
# The sigmoid function is used to switch off the path tracking controller smoothly to the nominal controller
# when the robot is close to the end of path. See: https://www.desmos.com/calculator/exgon3okr6
d_path_tracking_switch_off_distance: 1.00 # 0.75 # the distance from the end of the path to start switching off the path tracking controller
k_path_tracking_switch_off_smoothness: 10.0 # 20.0 # the higher the value, the steeper the switch off of the path tracking controller

# Feedforward velocity scale factors for the path tracking controller
# These values are multiplied with the maximum velocity limits to scale down the velocity commands of the path tracking
# They are in the range of [0,1]. If the value is 1.0, the maximum velocity limits are used as the feedforward velocity commands.
path_tracking_feedforward_linear_velocity_scale_factor: 1.0 # 0.5
path_tracking_feedforward_angular_velocity_scale_factor: 1.0 # 0.5


## -------------------------------------------------------
## Obstacle avoidance parameters

k_low_pass_min_d: 0.1 # low pass filter coefficient for the ratio of minimum distance values of the previous values (Must be between [0,1])

# offset distance from the obstacles
d_obstacle_offset: 0.05 # (meter) 

d_obstacle_freezone: 2.0 # (meter) # further than this distance, no obstacles considered by the controller 

# # alpha(h) function obstacle avoidance coefficients 
# # Piecewise linear function slope coefficients 
# # decrease c1_alpha_obstacle to start reacting early to be more safe, (but causes less nominal controller following)
# # increase c2_alpha_obstacle to remove the offset violation more agressively, (but may cause instability due to the discretization if too agressive)
# c1_alpha_obstacle: 0.05 # 0.05 # for h >= 0 # 0.4 # 0.8 # 0.01 # 0.01 # 0.00335 
# c2_alpha_obstacle: 2.0 # 2.0 # for h < 0 # 5.0 # 3.0 # 0.04 # 0.02 # 0.01 

# alpha(h) function obstacle avoidance coefficients NEW
# see: https://www.desmos.com/calculator/hc6lc7nzkk for the function visualizations
c1_alpha_obstacle: 0.25 # 0.08 # Decrease this to start reacting early 
c2_alpha_obstacle: 4.0 # 2.7 # 4.0 # 1.16 # 
c3_alpha_obstacle: 2.0 # linear slope if h < 0 # Increase this to remove the offset violation more agressively

## -------------------------------------------------------
## Stress avoidance parameters

k_low_pass_ft: 0.9 # low pass filter coefficient for the ratio of ft values of the previous values (Must be between [0,1])

wrench_max: [200.0, 200.0, 200.0, 15.0, 15.0, 15.0] # maximum wrench values for each axis [Fx,Fy,Fz, Tx,Ty,Tz] for the Control Barrier Functions (CBF)s. 
# w_stress_offset: [30.0, 30.0, 30.0, 2.25, 2.25, 2.25] # offset values for the stress violation for each axis [Fx,Fy,Fz, Tx,Ty,Tz]
w_stress_offset: [60.0, 60.0, 60.0, 4.5, 4.5, 4.5] # offset values for the stress violation for each axis [Fx,Fy,Fz, Tx,Ty,Tz]

# alpha(h_ft) function robot stress coefficients for each axis [Fx,Fy,Fz, Tx,Ty,Tz]
# see: https://www.desmos.com/calculator/hc6lc7nzkk for the function visualizations
# c1_alpha_ft: [0.1, 0.1, 0.1, 0.01, 0.01, 0.01] # Decrease this to start reacting early  
c1_alpha_ft: [9, 9, 9, 0.6, 0.6, 0.6] # Decrease this to start reacting early  
# c1_alpha_ft: [150, 150, 150, 20, 20, 20] # Decrease this to start reacting early TOO RELAXED  

c2_alpha_ft: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0] # DO NOT CHANGE FROM 1.0. EXPERIMENTAL

# c3_alpha_ft: [10.0, 10.0, 10.0, 30.0, 30.0, 30.0] # linear slope if h < 0 # Increase this to remove the offset violation more agressively # SEEMS TOO RELAXED FOR Fx,Fy,Fz
c3_alpha_ft: [90.0, 90.0, 90.0, 30.0, 30.0, 30.0] # linear slope if h < 0 # Increase this to remove the offset violation more agressively
# c3_alpha_ft: [150.0, 150.0, 150.0, 30.0, 30.0, 30.0] # linear slope if h < 0 # Increase this to remove the offset violation more agressively
# c3_alpha_ft: [200.0, 200.0, 200.0, 30.0, 30.0, 30.0] # linear slope if h < 0 # Increase this to remove the offset violation more agressively
# c3_alpha_ft: [400.0, 400.0, 400.0, 30.0, 30.0, 30.0] # linear slope if h < 0 # Increase this to remove the offset violation more agressively
# c3_alpha_ft: [70.0, 70.0, 70.0, 90.0, 90.0, 90.0] # SEEMS TOO AGRESSIVE FOR Tx,Ty,Tz

## -------------------------------------------------------
